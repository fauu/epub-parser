{"version":3,"sources":["../../webpack/bootstrap a499f53419c70a4d8938","../.././src/parseLink.ts","../../external \"lodash\"","../.././src/parseHTML.ts","../.././src/utils.ts","../.././src/index.ts","../.././src/epubParser.ts","../.././src/mdConverters.ts","../.././src/parseSection.ts","../../external \"debug\"","../../external \"fs\"","../../external \"jsdom\"","../../external \"node-zip\"","../../external \"path\"","../../external \"to-markdown\"","../../external \"xml2js\""],"names":[],"mappings":";;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;;;;;ACZA,mC;;;;;;;;;;;;ACAA;AACA;AAC4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,WAAW,0BAA0B;AACrC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0DAA0D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AAC4B;AACpB;AACR;;;;;;;;;;;;;;;;;;ACLA;AAAA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAyC,gDAAgD;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA,mBAAmB,OAAO;AAC1B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8FAAiD,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AAAA;AAAA;AACA,2CAA0D;AAC1D;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY,GAAG,YAAY;AAClD;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA,uBAAuB,QAAQ,GAAG,iBAAiB;AACnD;AACA;AACA;AACA,wBAAwB,QAAQ,GAAG,UAAU;AAC7C;AACA;AACA,qBAAqB,KAAK,OAAO,GAAG,IAAI,uCAAuC,IAAI,KAAK;AACxF;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU,IAAI,2BAA2B;AAC9D;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAuD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,mCAAmC,UAAU,GAAG,KAAK;AACrD;AACA,+BAA+B,UAAU;AACzC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS,OAAO;AAC3D;AACA;AACA;AACA,SAAS;AACT;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;ACrDA,kC;;;;;;ACAA,+B;;;;;;ACAA,kC;;;;;;ACAA,qC;;;;;;ACAA,iC;;;;;;ACAA,wC;;;;;;ACAA,mC","file":"epubParser.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a499f53419c70a4d8938","import _ from 'lodash';\nexport default function parseHref(href) {\n    const hash = href.split('#')[1];\n    const url = href.split('#')[0];\n    const prefix = url.split('/').slice(0, -1).join('/');\n    const filename = _.last(url.split('/'));\n    const name = filename.split('.').slice(0, -1).join('.');\n    let ext = _.last(filename.split('.'));\n    if (filename.indexOf('.') === -1) {\n        ext = '';\n    }\n    return { hash, name, ext, prefix, url };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/parseLink.ts\n// module id = 0\n// module chunks = 0","module.exports = require(\"lodash\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash\"\n// module id = 1\n// module chunks = 0","import jsdom from 'jsdom';\nimport _ from 'lodash';\nimport { parseNestedObject } from './utils';\nconst debug = require('debug')('readr:html');\nconst OMITTED_TAGS = ['head', 'input', 'textarea', 'script', 'style', 'svg'];\nconst UNWRAP_TAGS = ['body', 'html', 'div', 'span'];\nconst PICKED_ATTRS = ['href', 'src', 'id'];\nconst parseRawHTML = HTMLString => {\n    return jsdom\n        .jsdom(HTMLString, {\n        features: {\n            FetchExternalResources: [],\n            ProcessExternalResources: false\n        }\n    })\n        .documentElement;\n};\n/**\n * recursivelyReadParent\n * @param node\n * @param callback invoke every time a parent node is read, return truthy value to stop the reading process\n * @param final callback when reaching the root\n */\nconst recursivelyReadParent = (node, callback, final) => {\n    const _read = (_node) => {\n        const parent = _node.parentNode;\n        if (parent) {\n            const newNode = callback(parent);\n            if (!newNode) {\n                return _read(parent);\n            }\n            return newNode;\n        }\n        else {\n            if (final) {\n                return final();\n            }\n            return node;\n        }\n    };\n    return _read(node);\n};\nconst parseHTMLObject = (HTMLString, config = {}) => {\n    debug('parseHTMLObject');\n    const rootNode = parseRawHTML(HTMLString);\n    const { resolveHref, resolveSrc } = config;\n    // initial parse\n    return parseNestedObject(rootNode, {\n        childrenKey: 'childNodes',\n        preFilter(node) {\n            return node.nodeType === 1 || node.nodeType === 3;\n        },\n        parser(node, children) {\n            if (node.nodeType === 1) {\n                const tag = node.tagName.toLowerCase();\n                const attrs = {};\n                if (OMITTED_TAGS.indexOf(tag) !== -1) {\n                    return null;\n                }\n                if (UNWRAP_TAGS.indexOf(tag) !== -1 && children) {\n                    return children.length === 1 ? children[0] : children;\n                }\n                PICKED_ATTRS.forEach(attr => {\n                    let attrVal = node.getAttribute(attr) || undefined;\n                    if (attrVal && attr === 'href' && resolveHref) {\n                        attrVal = resolveHref(attrVal);\n                    }\n                    if (attrVal && attr === 'src' && resolveSrc) {\n                        attrVal = resolveSrc(attrVal);\n                    }\n                    attrs[attr] = attrVal;\n                });\n                return { tag, type: 1, children, attrs };\n            }\n            else {\n                const text = node.textContent.trim();\n                if (!text) {\n                    return null;\n                }\n                const makeTextObject = () => {\n                    return {\n                        type: 3,\n                        text\n                    };\n                };\n                // find the cloest parent which is not in UNWRAP_TAGS\n                // if failed then wrap with p tag\n                return recursivelyReadParent(node, parent => {\n                    const tag = parent.tagName && parent.tagName.toLowerCase();\n                    if (!tag || (UNWRAP_TAGS.indexOf(tag) !== -1)) {\n                        return false;\n                    }\n                    return makeTextObject();\n                }, () => {\n                    return {\n                        tag: 'p',\n                        children: [makeTextObject()]\n                    };\n                });\n            }\n        },\n        postFilter(node) {\n            return !_.isEmpty(node);\n        }\n    });\n};\nexport default parseHTMLObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/parseHTML.ts\n// module id = 2\n// module chunks = 0","import _ from 'lodash';\n/**\n * parseNestedObject\n * a note about config.parser\n * `children` is a recursively parsed object and should be returned for parser to take effect\n * objects without `children` will be parsed by finalParser\n * @param _rootObject\n * @param config\n */\nconst parseNestedObjectWrapper = (_rootObject, config) => {\n    const { childrenKey, parser, preFilter, postFilter, finalParser } = config;\n    if (!_rootObject) {\n        return [];\n    }\n    const parseNestedObject = (rootObject) => {\n        const makeArray = () => {\n            if (Array.isArray(rootObject) || _.isArrayLikeObject(rootObject) || _.isArrayLike(rootObject)) {\n                return rootObject;\n            }\n            return [rootObject];\n        };\n        const rootArray = makeArray();\n        let result = rootArray;\n        if (preFilter) {\n            result = _.filter(result, preFilter);\n        }\n        result = _.map(result, (object, index) => {\n            if (object[childrenKey]) {\n                const parsedChildren = parseNestedObject(object[childrenKey]);\n                // in parseHTML, if a tag is in unwrap list, like <span>aaa<span>bbb</span></span>\n                // the result needs to be flatten\n                const children = _.isEmpty(parsedChildren) ? undefined : _.flattenDeep(parsedChildren);\n                if (parser) {\n                    return parser(object, children);\n                }\n                return Object.assign({}, object, {\n                    [childrenKey]: children\n                });\n            }\n            if (finalParser) {\n                return finalParser(object);\n            }\n            return object;\n        });\n        if (postFilter) {\n            result = _.filter(result, postFilter);\n        }\n        return result;\n    };\n    return _.flattenDeep(parseNestedObject(_rootObject));\n};\nexport const parseNestedObject = parseNestedObjectWrapper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.ts\n// module id = 3\n// module chunks = 0","import parser from './epubParser';\nimport parseLink from './parseLink';\nimport parseHTML from './parseHTML';\nimport { parseNestedObject } from './utils';\nexport { parseLink, parseHTML, parseNestedObject };\nexport default parser;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 4\n// module chunks = 0","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport fs from 'fs';\nimport xml2js from 'xml2js';\nimport _ from 'lodash';\nimport nodeZip from 'node-zip';\nimport parseLink from './parseLink';\nimport parseSection from './parseSection';\nconst xmlParser = new xml2js.Parser();\nconst xmlToJs = (xml) => {\n    return new Promise((resolve, reject) => {\n        xmlParser.parseString(xml, (err, object) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(object);\n            }\n        });\n    });\n};\nconst determineRoot = (opfPath) => {\n    let root = '';\n    // set the opsRoot for resolving paths\n    if (opfPath.match(/\\//)) {\n        root = opfPath.replace(/\\/([^\\/]+)\\.opf/i, '');\n        if (!root.match(/\\/$/)) {\n            root += '/';\n        }\n        if (root.match(/^\\//)) {\n            root = root.replace(/^\\//, '');\n        }\n    }\n    return root;\n};\nconst parseMetadata = (metadata) => {\n    const title = _.get(metadata[0], ['dc:title', 0]);\n    let author = _.get(metadata[0], ['dc:creator', 0]);\n    if (typeof author === 'object') {\n        author = _.get(author, ['_']);\n    }\n    const publisher = _.get(metadata[0], ['dc:publisher', 0]);\n    const meta = {\n        title,\n        author,\n        publisher\n    };\n    return meta;\n};\nexport class Epub {\n    constructor(buffer) {\n        this._zip = new nodeZip(buffer, { binary: true, base64: false, checkCRC32: true });\n    }\n    resolve(path) {\n        let _path;\n        if (path[0] === '/') {\n            // use absolute path, root is zip root\n            _path = path.substr(1);\n        }\n        else {\n            _path = this._root + path;\n        }\n        const file = this._zip.file(decodeURI(_path));\n        if (file) {\n            return file;\n        }\n        else {\n            throw new Error(`${_path} not found!`);\n        }\n    }\n    _resolveXMLAsJsObject(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const xml = this.resolve(path).asText();\n            return xmlToJs(xml);\n        });\n    }\n    _getOpfPath() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const container = yield this._resolveXMLAsJsObject('/META-INF/container.xml');\n            const opfPath = container.container.rootfiles[0].rootfile[0]['$']['full-path'];\n            return opfPath;\n        });\n    }\n    _getManifest(content) {\n        return _.get(content, ['package', 'manifest', 0, 'item'], [])\n            .map(item => item.$);\n    }\n    _resolveIdFromLink(href) {\n        const { name: tarName } = parseLink(href);\n        const tarItem = _.find(this._manifest, item => {\n            const { name } = parseLink(item.href);\n            return name === tarName;\n        });\n        return _.get(tarItem, 'id');\n    }\n    _getSpine() {\n        return _.get(this._content, ['package', 'spine', 0, 'itemref'], [])\n            .map(item => {\n            return item.$.idref;\n        });\n    }\n    _genStructure(tocObj, resolveNodeId = false) {\n        const rootNavPoints = _.get(tocObj, ['ncx', 'navMap', '0', 'navPoint'], []);\n        const parseNavPoint = (navPoint) => {\n            // link to section\n            const path = _.get(navPoint, ['content', '0', '$', 'src'], '');\n            const name = _.get(navPoint, ['navLabel', '0', 'text', '0']);\n            const playOrder = _.get(navPoint, ['$', 'playOrder']);\n            const { hash: nodeId } = parseLink(path);\n            let children = navPoint.navPoint;\n            if (children) {\n                // tslint:disable-next-line:no-use-before-declare\n                children = parseNavPoints(children);\n            }\n            const sectionId = this._resolveIdFromLink(path);\n            return {\n                name,\n                sectionId,\n                nodeId,\n                path,\n                playOrder,\n                children\n            };\n        };\n        const parseNavPoints = (navPoints) => {\n            return navPoints.map(point => {\n                return parseNavPoint(point);\n            });\n        };\n        return parseNavPoints(rootNavPoints);\n    }\n    _resolveSectionsFromSpine(expand = false) {\n        // no chain\n        return _.map(_.union(this._spine), id => {\n            const path = _.find(this._manifest, { id }).href;\n            const html = this.resolve(path).asText();\n            return parseSection({\n                id,\n                htmlString: html,\n                resourceResolver: this.resolve.bind(this),\n                idResolver: this._resolveIdFromLink.bind(this),\n                expand\n            });\n        });\n    }\n    parse(expand = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const opfPath = yield this._getOpfPath();\n            this._root = determineRoot(opfPath);\n            const content = yield this._resolveXMLAsJsObject('/' + opfPath);\n            const manifest = this._getManifest(content);\n            const tocID = _.get(content, ['package', 'spine', 0, '$', 'toc'], '');\n            const tocPath = _.find(manifest, { id: tocID }).href;\n            const toc = yield this._resolveXMLAsJsObject(tocPath);\n            const metadata = _.get(content, ['package', 'metadata'], []);\n            this._manifest = manifest;\n            this._content = content;\n            this._opfPath = opfPath;\n            this._toc = toc;\n            this._spine = this._getSpine();\n            this._metadata = metadata;\n            this.info = parseMetadata(metadata);\n            this.sections = this._resolveSectionsFromSpine(expand);\n            this.structure = this._genStructure(toc);\n            return this;\n        });\n    }\n}\nexport default function parserWrapper(target, options = {}) {\n    // seems 260 is the length limit of old windows standard\n    // so path length is not used to determine whether it's path or binary string\n    // the downside here is that if the filepath is incorrect, it will be treated as binary string by default\n    // but it can use options to define the target type\n    const { type, expand } = options;\n    let _target = target;\n    if (type === 'path' || (typeof target === 'string' && fs.existsSync(target))) {\n        _target = fs.readFileSync(target, 'binary');\n    }\n    return new Epub(_target).parse(expand);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/epubParser.ts\n// module id = 5\n// module chunks = 0","import parseLink from './parseLink';\nexport const resolveInlineNavHref = href => {\n    if (href && href.indexOf('http://') === -1) {\n        const parsed = parseLink(href);\n        if (parsed.hash) {\n            return `#${parsed.name}$${parsed.hash}`;\n        }\n        return `#${parsed.name}`;\n    }\n    return href;\n};\nexport const h = {\n    filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n    replacement: function (innerHTML, node) {\n        let hLevel = node.tagName.charAt(1);\n        let hPrefix = '';\n        for (let i = 0; i < hLevel; i++) {\n            hPrefix += '#';\n        }\n        // return `\\n${hPrefix} ${innerHTML.trim()}\\n\\n`\n        const hTag = node.tagName.toLowerCase();\n        const id = node.getAttribute('id');\n        if (!id) {\n            return `\\n${hPrefix} ${innerHTML}\\n\\n`;\n        }\n        // 块级元素若保留原标签需添加换行符，否则临近元素渲染会出现问题\n        return `\\n<${hTag} id=\"${id}\">${innerHTML.trim().split('\\n').join(' ')}</${hTag}>\\n\\n`;\n    }\n};\nexport const span = {\n    filter: ['span'],\n    replacement: function (innerHTML, node) {\n        return innerHTML;\n    }\n};\nexport const a = {\n    filter: ['a'],\n    replacement: function (innerHTML, node) {\n        const href = node.getAttribute('href');\n        return `\\n[${innerHTML}](${resolveInlineNavHref(href)})\\n\\n`;\n    }\n};\nexport const div = {\n    filter: ['div'],\n    replacement: function (innerHTML, node) {\n        return `\\n${innerHTML}\\n\\n`;\n    }\n};\nexport const img = {\n    filter: ['img'],\n    replacement: function (innerHTML, node) {\n        return `\\n[图]\\n\\n`;\n    }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/mdConverters.ts\n// module id = 6\n// module chunks = 0","import path from 'path';\nimport toMarkdown from 'to-markdown';\nimport parseLink from './parseLink';\nimport parseHTML from './parseHTML';\nimport * as mdConverters from './mdConverters';\nconst isInternalUri = (uri) => {\n    return uri.indexOf('http://') === -1 && uri.indexOf('https://') === -1;\n};\nexport class Section {\n    constructor({ id, htmlString, resourceResolver, idResolver, expand }) {\n        this.id = id;\n        this.htmlString = htmlString;\n        this._resourceResolver = resourceResolver;\n        this._idResolver = idResolver;\n        if (expand) {\n            this.htmlObjects = this.toHtmlObjects();\n        }\n    }\n    toMarkdown() {\n        return toMarkdown(this.htmlString, {\n            converters: [mdConverters.h, mdConverters.span, mdConverters.div, mdConverters.img, mdConverters.a]\n        });\n    }\n    toHtmlObjects() {\n        return parseHTML(this.htmlString, {\n            resolveHref: (href) => {\n                if (isInternalUri(href)) {\n                    const { hash } = parseLink(href);\n                    // todo: what if a link only contains hash part?\n                    const sectionId = this._idResolver(href);\n                    if (hash) {\n                        return `#${sectionId},${hash}`;\n                    }\n                    return `#${sectionId}`;\n                }\n                return href;\n            },\n            resolveSrc: (src) => {\n                if (isInternalUri(src)) {\n                    // todo: may have bugs\n                    const absolutePath = path.resolve('/', src).substr(1);\n                    const buffer = this._resourceResolver(absolutePath).asNodeBuffer();\n                    const base64 = buffer.toString('base64');\n                    return `data:image/png;base64,${base64}`;\n                }\n                return src;\n            }\n        });\n    }\n}\nconst parseSection = (config) => {\n    return new Section(config);\n};\nexport default parseSection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/parseSection.ts\n// module id = 7\n// module chunks = 0","module.exports = require(\"debug\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"debug\"\n// module id = 8\n// module chunks = 0","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 9\n// module chunks = 0","module.exports = require(\"jsdom\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jsdom\"\n// module id = 10\n// module chunks = 0","module.exports = require(\"node-zip\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"node-zip\"\n// module id = 11\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 12\n// module chunks = 0","module.exports = require(\"to-markdown\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"to-markdown\"\n// module id = 13\n// module chunks = 0","module.exports = require(\"xml2js\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"xml2js\"\n// module id = 14\n// module chunks = 0"],"sourceRoot":""}